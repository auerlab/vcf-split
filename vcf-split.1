.TH VCF-SPLIT 1
.SH NAME    \" Section header
.PP
 
vcf-split \- Efficiently split a multi-sample VCF stream into single-sample files

\" Convention:
\" Underline anything that is typed verbatim - commands, etc.
.SH SYNOPSIS
.PP
.nf 
.na 
vcf-split [--het-only] [--max-calls N] [--sample-id-file file] 
    output-file-prefix first-column last-column < file.vcf

bcftools view file.bcf | vcf-split ...
.ad
.fi

.SH OPTIONS and ARGUMENTS
.TP
\fB\-\-het\-only
Output only heterozygous sites.  When decoding a BCF file,
"bcftools view --genotype het" slows down the "bcftools view" process
and vcf-split uses far less CPU.  Since bcftools is already saturating a
CPU core and vcf-split has CPU cycles to spare, allowing vcf-split
to perform the heterozygous site selection increases pipeline performance
considerably.

.TP
\fB\-\-max\-calls N
Limit the number of VCF calls (for quick testing without the need to
generat smaller input samples)

.TP
\fB\-\-sample\-id\-file filename
File containing a whitespace-separated arbitrary list of sample IDS

.TP
.B output-file-prefix
Common filename prefix for all single-sample output files

.TP
.B first-column last-column
1-based column numbers limiting the number of samples
for each run.  E.g. for a 100,000 sample VCF stream

\" Optional sections
.SH "PURPOSE"

.B vcf-split
efficiently splits a multi-sample VCF stream into single-sample VCF files.

.SH "DESCRIPTION"

Traditional methods for splitting a multi-sample VCF stream into single-sample
files involve a loop or parallel job that rereads the multi-sample input for
every sample.  This can
become a major bottleneck where there are many samples and/or the input
is compressed.  For example, using "bcftools view" with optimal filtering
options to merely decode one human chromosome BCF with
137,977 samples and pipe the VCF output through "wc" took 12 hours on a
fast server using 2 cores.  To split it into 137,977 single-sample VCFs
would therefore require about 137,977 * 12 * 2 = ~3 million core-hours.
This translates to 171 years on a single server or 125 days using 1000 cores
on an HPC cluster.

.B vcf-split
solves this problem by writing a large number of single-sample VCFs
simultaneously during a single read of the multi-sample input.  The number
of parallel output files is limited only by the open file limit of your
system, which is typically at least in the tens of thousands on a modern
Unix workstation or server.

.B vcf-split
is written entirely in C and attempts to optimize CPU, memory,
and disk access.  It does not inhale large amounts of data into RAM, so memory
use is trivial and it runs mostly from cache, making computational code
as fast as possible.

The example BCF file mentioned above can be split in a few days on a single
server using two cores and three runs of about 45,000 output files each.

.SH "SEE ALSO"
ad2vcf, haplohseq

.SH "EXAMPLES"

vcf-split < input.vcf --het-only single-sample- 1 100

bcftools view --min-ac 2 --exclude-types indels \\
    ../phased/freeze.8.chr1.pass_only.phased.bcf \\
    | vcf-split --het-only \\
    --sample-id-file LLS_WHIMS_NWDID_TOPMED.csv chr01. 1 137977

.SH BUGS
Please report bugs to the author and send patches in unified diff format.
(Run "man diff" for more information)

.SH AUTHOR
.nf
.na
Jason W. Bacon
Paul Auer Lab
UW -- Milwaukee Zilber School of Public Health
